\input{labspre.tex}

\usepackage[compact]{titlesec}

\begin{document} \MYTITLE{Laboratory Assignment Six: Doubling Experiments for Inferring Time Complexities}
\MYHEADERS{Laboratory Assignment Six}{Due: October 24, 2016}

\section*{Introduction}

The current module of the course has focused on the importance and purpose of both empirical and analytical evaluations
of algorithm performance. For this laboratory assignment, we will learn how to use a tool, called {\sc ExpOse}, that
leverages the results from successive doubling experiments to infer the ``actual-worst-case'' time complexity of an
algorithm. Using examples provided with {\sc ExpOse}, you will experimentally determine the actual-worst-case time
complexity of several sorting algorithms and two algorithms for determining if there are no duplicate elements in an
array. Ultimately, you work aims to experimentally confirm some of the analytical evaluations of an algorithm provided
in your textbook and in online sources. Throughout this assignment, you will take additional steps towards seeing the
connection between the experimental and analytical evaluation of algorithms. Finally, you will continue to practice the
use of software engineering tools.

\section*{Review Your Textbook}

To do well on this laboratory assignment, you should review the content about sorting an array in Section 3.1.2
(optionally, students may investigate a more advanced analysis of these algorithms by reading Section 9.4.1 of the
textbook). Next, you should carefully review the content in Section 4.1, paying particularly close attention to the
results in Table 4.1 and Figure 4.1. To learn more about the uniqueness detection algorithms studied in this assignment,
please read Section 4.3.3, specifically noting Code Fragments 4.7 and 4.8.  Additionally, you should also examine the
slides that we have discussed during our recent class sessions. If you have questions about this reading assignment or
the material that was presented in class, then please see the course instructor. If done appropriately, you may also
post your question to the {\tt \#laboratory} channel of our Slack team.

\section*{Downloading the {\sc ExpOse} Tool from GitHub}

You should complete this assignment with a partner; please ensure that you are working with someone who is different
than your previous partners. Both members of the partnership are required to complete all of the steps for this
laboratory assignment. To start this assignment, you should go to the {\tt https://github.com/kinneerc/ExpOse} web site
and click the large green button to the right of the screen to see the SSH-based name for the repository. Now, use this
repository name as the command-line argument to the ``{\tt git clone}'' command that you run in your terminal window.

At this point, you will have downloaded the entire {\sc ExpOse} system from the GitHub servers and saved it on your own
computer. Each person is the partnership should ensure that they have their own download of {\sc ExpOse} as there is no
need for your partnership to have a joint repository. Next, you should use GVim to study the source code in the {\tt
build.xml} file that comes with the {\sc ExpOse} tool. As in the past assignments, when creating and using a Java
program you can type ``{\tt ant compile}'' in your terminal window and it will compile the Java class and save the
bytecode in the correct subdirectories inside of the {\tt bin/} directory. Please see the course instructor if you
cannot get this to work. Next, you should load the source code of the {\tt SortingExperiment} into GVim so that you can
study it carefully. What sorting algorithms does this {\sc ExpOse} experimentally study? Finally, please examine the
source code of the {\tt UniqueExperiment}. What are the uniqueness detection algorithms that it studies? Make sure that
you look at the source code of each of these algorithms, studying their structure as you try to discern their worst-case
time complexity. Which of the algorithms are most efficient? Which of the algorithm seem to be be less efficient? Why?

\section*{Understanding the Approach Taken by {\sc ExpOse}}

In the last assignment, you studied statements in your textbook about a pattern that you could follow when making
observations about an algorithm's time overhead. For instance, when describing the results from running the {\tt
StringExperiment}, page 153 notes that ``[A]s the value of $n$ is doubled, the running time of {\tt repeat1} typically
increases more than fourfold.'' What does this suggest about the likely worst-case time complexity of the {\tt repeat1}
method? Additionally, page 172 includes the following statement when describing the performance of {\tt repeat2}: ``the
running times in that table $\ldots$ demonstrate a trend of approximately doubling each time the problem size doubles.''
Again, what would this observation suggest about the likely worst-case time complexity of {\tt repeat2}?

\begin{table}[t]

  \begin{center}

    \begin{tabular}{c|l}
      Ratio $f(2n)/f(n)$ & Worst-Case Conclusion              \\ \hline
      1                  & constant or logarithmic \\
      2                  & linear or linearithmic  \\
      4                  & quadratic               \\
      8                  & cubic                   \\
      % x                & $O(n^{\log x})$
    \end{tabular}

  \end{center}
  \vspace*{-.25in}

  % GMK NOTE: Making a shorter caption helps the formatting on the second page
  \caption{Actual-worst-case time complexity conclusions drawn from the doubling ratio $f(2n)/f(n)$.}\label{table:ratios}
  % \vspace*{-.35in}

\end{table}

A useful understanding of an algorithm's efficiency, the worst-case time complexity gives an upper bound on how an
increase in the size of the input, denoted $n$, increases the execution time of the algorithm, $f(n)$. We have learned
in class that this relationship is often expressed in the ``big-Oh'' notation, where $f(n)$ is $O(g(n))$ means that the
time increases by no more than on order of $g(n)$. Since the worst-case complexity of an algorithm is evident when $n$
is large, one approach for determining the big-Oh complexity of an algorithm is to conduct a doubling experiment with
increasingly bigger input sizes. By measuring the time needed to run the algorithm on an input of size $n$ and the time
needed to run with input of size $2n$, the algorithm's order of growth can be empirically determined.
The goal of a doubling experiment is to draw a conclusion about the efficiency of the algorithm from the ratio
$f(2n)/f(n)$ that represents the factor of change in runtime from input sizes $n$ to $2n$. For instance, a ratio of $2$
would indicate that doubling the input size resulted in the runtime's doubling, thus leading to the conclusion that the
algorithm under study is $O(n)$ or $O(n\log n)$. Table~\ref{table:ratios} shows some common time complexities and their
corresponding ratios.

As you saw in the previous laboratory assignment, it is time consuming and challenging to implement your own framework
for conducting a doubling experiment. Therefore, in this assignment, you will learn how to use {\sc ExpOse}, a tool that
can automatically conduct a doubling experiment for you. Once your algorithm is added to {\sc ExpOse} (like the sorting
and uniqueness detection algorithms that have already been integrated), you can use the tool to automatically conduct an
experiment and reach a conclusion about the likely worst-case time complexity of an algorithm (since this inference is
based on data observations from actual runs of an algorithm, the suggested complexity is called ``actual-worst-case'' in
the remainder of this assignment sheet). It is nice to use {\sc ExpOse} when you want to confirm that an already-known
worst-case time complexity is correct or you want to develop an intuition about an algorithms worst-case behavior.
Overall, using a tool like {\sc ExpOse} enables you to make a clear link between the analytical and experimental
evaluation of an algorithms efficiency. In the remainder of this assignment, we will use {\sc ExpOse} to confirm the
conclusions that your textbook's authors have reached concerning the worst-case time complexity of two different types of
algorithms (e.g., sorting algorithms and uniqueness detection algorithms).

\section*{Determining ``Actual-Worst-Case'' Time Complexity}

\section*{Carefully Review the Honor Code}

The Academic Honor Program that governs the entire academic program at Allegheny College is described in the Allegheny
Academic Bulletin. The Honor Program applies to all work that is submitted for academic credit or to meet non-credit
requirements for graduation at Allegheny. This includes all work assigned for this class (e.g., examinations, laboratory
assignments, and the final project). All students who have enrolled in the College will work under the Honor Program.

% Each student who has matriculated at the College has acknowledged the following pledge:
% \vspace*{-.1in}
% \begin{quote}
%   I hereby recognize and pledge to fulfill my responsibilities, as defined in the Honor Code, and to maintain the
%   integrity of both myself and the College community as a whole.
% \end{quote}
% \vspace*{-.1in}

% \noindent It is understood that an important part of the learning process in any course, and particularly one in
% computer science, derives from thoughtful discussions with teachers and fellow students.  Such dialogue is encouraged.
% However, it is necessary to distinguish carefully between the student who discusses the principles underlying a problem
% with others and the student who produces assignments that are identical to, or merely variations on, someone else's
% work. While it is acceptable for partners in this class to discuss their programs, data sets, and reports with their
% classmates, deliverables that are nearly identical to the work of others will be taken as evidence of violating the
% \mbox{Honor Code}.

\section*{Summary of the Required Deliverables}

This assignment invites you to submit a signed and printed version of the following deliverables:

\begin{enumerate}

  \itemsep0in

  \item A sample output from running all doubling experiments in all of their relevant configurations.

  \item A description of all of the features supported by your own doubling experiment tool.

  \item Using JavaDoc comments, the documented version of the {\tt StringExperiment} source code.

  \item A comprehensive written report that fully explains the results of your experimental studies.

  \item A reflective commentary on the challenges that you faced when implementing your program.

  \item A reflective commentary on the challenges that you faced when conducting the experiments.

  \item Suggestions for the types of laboratory assignments that you would like to later complete.

\end{enumerate}

Again, along with turning in a printed version of these deliverables, you should ensure that everything is also
available in the repository that is named according to the convention {\tt cs112F2016-<your user name>}. Please remember
that students in the class are responsible for completing and submitting their own version of this assignment. You
should see the instructor if you have any questions.

% While it is acceptable for members of this class to have high-level conversations, you should not share source code or
% full command lines with your classmates.  Deliverables that are nearly identical to the work of others will be taken as
% evidence of violating the \mbox{Honor Code}.  Please see the instructor if you have questions about the policies for
% this assignment.

\end{document}
